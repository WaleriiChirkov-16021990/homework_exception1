import java.io.FileNotFoundException;
import java.util.Arrays;

public class Main {
	public static void main(String[] args) throws FileNotFoundException {
		/*
		№1
			- Реализуйте 3 метода, чтобы в каждом из них получить разные исключения
			- Посмотрите на код, и подумайте сколько разных типов исключений вы тут сможете получить?
*/
		Class_for_trow_exception c = new Class_for_trow_exception();
		
//		System.out.println(Class_for_trow_exception.readLocalFile("src/fileInt.tx"));
//		==============================================================================
//		    Строка выше попытается считать не существующий файл, и мы получим Exception +  предусмотренное сообщение об инциденте;

		System.out.println(Class_for_trow_exception.readLocalFile("src/fileInt.txt"));
//		=================================================================================
//          Строка выше прочитает существующий файл , в котором лежат валидные данные для программы

//		System.out.println(Class_for_trow_exception.readLocalFile("src/fileString.txt"));
//		==================================================================================
//          Строка выше прочтёт существующий файл, в котором лежат не валидные данные, получаем Exception + информационное сообщение

//		c.list = new ArrayList<>(); //
//		c.addList(4);  //
//		    @ 2 строки выше демонстрируют нам алгоритм по обработке 1 исключения (NullPointerException) Если не рассскомментировать строку 13, не произойдет
//		инициализация списка, и при попытки добавления любого элемента в этот список мы получим исключение.

//		System.out.println(c.divNumbers(1,0)); // Данная строка предупредит пользователя о попытке деления на 0 и вернет "0".

//		System.out.println(c.divNumbers(10,5)); // А эта строчка выполнит деление, так как в ней нет арифметических ошибок и вернет результат = "2".
		
		/*
		№2
			Реализуйте метод, принимающий в качестве аргументов два целочисленных массива, и возвращающий новый массив,
			каждый элемент которого равен разности элементов двух входящих массивов в той же ячейке.
			Если длины массивов не равны, необходимо как-то оповестить пользователя.
        */
		int[] race = null;
//		null array для проверки
		
		Subtraction_array array = new Subtraction_array();
//		int[] a = array.sub(new int[]{1,2,3,4,5,7},new int[]{5,4,3,2,1,});
//		выше проверка при передаче массивов разной длины
		
		int[] a = array.sub(new int[]{1,2,3,4,5},new int[]{5,4,3,2,1,});
//		равные по длине массивы

//		int[] a = array.sub(race,new int[]{5,4,3,2,1,});
//		передаю null массив
		
		System.out.println(Arrays.toString(a));
//		вывод результата
		
		
		/*
		 * #3
		 * Реализуйте метод, принимающий в качестве аргументов два целочисленных массива, и возвращающий новый массив,
		 * каждый элемент которого равен частному элементов двух входящих массивов в той же ячейке.
		 * Если длины массивов не равны, необходимо как-то оповестить пользователя.
		 * Важно: При выполнении метода единственное исключение, которое пользователь может увидеть - RuntimeException, т.е. ваше.
		 */
		
		Division_elements_of_array div = new Division_elements_of_array();
		int[]com = null;
		//		null array для проверки
		
		double[] res = div.div(new int[]{4,6,8,10,16}, new int[]{2,2,2,2,2});
		//		равные по длине массивы
		
//		double[] res = div.div(com,new int[]{2,2,2,2,2});
		//		передаю null массив
		
//		double[] res = div.div(new int[]{4,6,8,10,16}, new int[]{2,2,0,2,2});
		//      передаю второй массив содержащий элемент равный 0
//
//		double[] res = div.div(new int[]{4,6,7,10,15,16}, new int[]{2,2,2,2,2});
		//		передаю массивы разной длины
		
		System.out.println(Arrays.toString(res));
		//		вывод результата
	}
	
	
	
}